$date
	Tue Jul  3 01:09:27 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module dut $end
$scope module myDecoder $end
$var wire 5 ! base [4:0] $end
$var wire 16 " immed [15:0] $end
$var wire 32 # instruction [31:0] $end
$var wire 16 $ offset [15:0] $end
$var wire 6 % opcode [5:0] $end
$var wire 32 & pc [31:0] $end
$var wire 5 ' rd [4:0] $end
$var wire 5 ( rs [4:0] $end
$var wire 5 ) rt [4:0] $end
$var wire 6 * sOpcode [5:0] $end
$var wire 6 + sa [5:0] $end
$var wire 26 , target [25:0] $end
$var reg 1 - ALUSrc $end
$var reg 1 . Branch $end
$var reg 1 / Jump $end
$var reg 1 0 MemEnable $end
$var reg 1 1 MemtoReg $end
$var reg 1 2 RegToImmediate $end
$var reg 1 3 RegWrite $end
$var reg 5 4 address_d [4:0] $end
$var reg 5 5 address_s1 [4:0] $end
$var reg 5 6 address_s2 [4:0] $end
$var reg 6 7 alu_opcode [5:0] $end
$var reg 32 8 immediate [31:0] $end
$var reg 1 9 isByte $end
$var reg 1 : readwrite $end
$upscope $end
$upscope $end
$scope module dut $end
$scope module myRegFile $end
$var wire 5 ; address_d [4:0] $end
$var wire 5 < address_s1 [4:0] $end
$var wire 5 = address_s2 [4:0] $end
$var wire 1 > clock $end
$var wire 32 ? data_dval [31:0] $end
$var wire 1 @ write_enable $end
$var reg 32 A data_s1val [31:0] $end
$var reg 32 B data_s2val [31:0] $end
$var integer 32 C i [31:0] $end
$upscope $end
$upscope $end
$scope module dut $end
$scope module myAlu $end
$var wire 6 D alu_opcode [5:0] $end
$var wire 32 E in_s1 [31:0] $end
$var wire 32 F in_s2 [31:0] $end
$var reg 1 G Branch $end
$var reg 32 H high [31:0] $end
$var reg 32 I low [31:0] $end
$var reg 64 J mul_res [63:0] $end
$var reg 32 K res [31:0] $end
$var reg 1 L zero $end
$upscope $end
$upscope $end
$scope module dut $end
$scope module myPC $end
$var wire 1 > clock $end
$var wire 32 M nextpc [31:0] $end
$var reg 32 N currentpc [31:0] $end
$upscope $end
$upscope $end
$scope module dut $end
$scope module icache $end
$var wire 32 O address [31:0] $end
$var wire 1 > clock $end
$var reg 32 P data_out [31:0] $end
$var integer 32 Q i [31:0] $end
$var reg 32 R start_address [31:0] $end
$upscope $end
$upscope $end
$scope module dut $end
$var wire 1 S ALUSrc $end
$var wire 1 T Branch $end
$var wire 1 U Jump $end
$var wire 1 V MemEnable $end
$var wire 1 W MemtoReg $end
$var wire 1 X RegToImmediate $end
$var wire 1 @ RegWrite $end
$var wire 5 Y address_d [4:0] $end
$var wire 5 Z address_s1 [4:0] $end
$var wire 5 [ address_s2 [4:0] $end
$var wire 6 \ alu_opcode [5:0] $end
$var wire 32 ] branchOutput [31:0] $end
$var wire 32 ^ branchingAddress [31:0] $end
$var wire 32 _ data_dval [31:0] $end
$var wire 32 ` data_s2val [31:0] $end
$var wire 32 a immediate [31:0] $end
$var wire 32 b in_s1 [31:0] $end
$var wire 32 c in_s2 [31:0] $end
$var wire 32 d incrementedpc [31:0] $end
$var wire 32 e instruction [31:0] $end
$var wire 1 f isByte $end
$var wire 32 g jumpAddress [31:0] $end
$var wire 32 h jumpInput [31:0] $end
$var wire 32 i memory_output [31:0] $end
$var wire 32 j nextpc [31:0] $end
$var wire 32 k pc [31:0] $end
$var wire 1 l read_write $end
$var wire 32 m res [31:0] $end
$var wire 1 n zero $end
$var reg 1 o clock $end
$var integer 32 p i [31:0] $end
$scope module myPC $end
$upscope $end
$scope module icache $end
$upscope $end
$scope module myDecoder $end
$upscope $end
$scope module myRegFile $end
$upscope $end
$scope module aluInputMux $end
$var wire 32 q input1 [31:0] $end
$var wire 32 r input2 [31:0] $end
$var wire 1 S sel $end
$var reg 32 s output1 [31:0] $end
$upscope $end
$scope module immediateOuputMux $end
$var wire 32 t input1 [31:0] $end
$var wire 32 u input2 [31:0] $end
$var wire 1 X sel $end
$var reg 32 v output1 [31:0] $end
$upscope $end
$scope module myAlu $end
$upscope $end
$scope module dataCache $end
$var wire 32 w address [31:0] $end
$var wire 1 > clock $end
$var wire 32 x data_in [31:0] $end
$var wire 1 V enable $end
$var wire 1 y isByte $end
$var wire 1 l read_write $end
$var reg 32 z data_out [31:0] $end
$var reg 32 { start_address [31:0] $end
$upscope $end
$scope module writebackInputMux $end
$var wire 32 | input1 [31:0] $end
$var wire 32 } input2 [31:0] $end
$var wire 1 W sel $end
$var reg 32 ~ output1 [31:0] $end
$upscope $end
$scope module pcBranchMux $end
$var wire 32 !" input1 [31:0] $end
$var wire 32 "" input2 [31:0] $end
$var wire 1 T sel $end
$var reg 32 #" output1 [31:0] $end
$upscope $end
$scope module pcJumpMux $end
$var wire 32 $" input1 [31:0] $end
$var wire 32 %" input2 [31:0] $end
$var wire 1 U sel $end
$var reg 32 &" output1 [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx &"
bx00 %"
bx $"
bx #"
bx ""
bx !"
bx ~
bx }
bx |
b10000000000000100000000000000000 {
bx z
zy
bx x
bx w
bx v
bx u
bx t
bx s
bx r
bx q
b0 p
1o
xn
bx m
0l
bx k
bx j
bx i
bx h
bx00 g
0f
b100111101111011111111111101000 e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
zX
0W
0V
0U
0T
0S
b10000000000000100000000000000000 R
b11100 Q
b100111101111011111111111101000 P
bx O
bx N
bx M
xL
bx K
bx J
bx I
bx H
xG
bx F
bx E
bx D
b100000 C
bx B
bx A
0@
bx ?
1>
bx =
bx <
bx ;
0:
09
bx 8
bx 7
bx 6
bx 5
bx 4
03
02
01
00
0/
0.
0-
b11101111011111111111101000 ,
b11111 +
b101000 *
b11101 )
b11101 (
b11111 '
bx &
b1001 %
b1111111111101000 $
b100111101111011111111111101000 #
b1111111111101000 "
b11101 !
$end
#5
b0xxxxx s
b0xxxxx F
b0xxxxx c
b0xxxxx B
b0xxxxx `
b0xxxxx q
b0xxxxx u
b0xxxxx x
b0xxxxx A
b0xxxxx E
b0xxxxx b
0o
0>
#10
b0xxxxxxxxxxxxxxxx00 g
b0xxxxxxxxxxxxxxxx00 %"
b0xxxxxxxxxxxxxxxx v
b0xxxxxxxxxxxxxxxx h
b1111111111101000 s
b1111111111101000 F
b1111111111101000 c
bx %
bx (
bx !
bx ,
bx )
bx '
bx $
bx "
b0xxxxx +
bx *
1-
1S
13
1@
b0 7
b0 D
b0 \
b11101 4
b11101 ;
b11101 Y
b1111111111101000 8
b1111111111101000 a
b1111111111101000 r
b1111111111101000 t
b11101 5
b11101 <
b11101 Z
bx P
bx #
bx e
1o
1>
b1 p
#15
b10000000000000101 ~
b10000000000000101 ?
b10000000000000101 _
0L
0n
b10000000000000101 K
b10000000000000101 m
b10000000000000101 w
b10000000000000101 |
b11101 A
b11101 E
b11101 b
0o
0>
#20
1o
1>
b10 p
#25
b1111111111101101 ~
b1111111111101101 ?
b1111111111101101 _
b1111111111101101 K
b1111111111101101 m
b1111111111101101 w
b1111111111101101 |
b101 A
b101 E
b101 b
0o
0>
#30
1o
1>
b11 p
#35
b1111111111110101 ~
b1111111111110101 ?
b1111111111110101 _
b1111111111110101 K
b1111111111110101 m
b1111111111110101 w
b1111111111110101 |
b1101 A
b1101 E
b1101 b
0o
0>
#40
1o
1>
b100 p
#45
b1111111111111101 ~
b1111111111111101 ?
b1111111111111101 _
b1111111111111101 K
b1111111111111101 m
b1111111111111101 w
b1111111111111101 |
b10101 A
b10101 E
b10101 b
0o
0>
#50
1o
1>
b101 p
#55
b10000000000000101 ~
b10000000000000101 ?
b10000000000000101 _
b10000000000000101 K
b10000000000000101 m
b10000000000000101 w
b10000000000000101 |
b11101 A
b11101 E
b11101 b
0o
0>
#60
1o
1>
b110 p
#65
b1111111111101101 ~
b1111111111101101 ?
b1111111111101101 _
b1111111111101101 K
b1111111111101101 m
b1111111111101101 w
b1111111111101101 |
b101 A
b101 E
b101 b
0o
0>
#70
1o
1>
b111 p
#75
b1111111111110101 ~
b1111111111110101 ?
b1111111111110101 _
b1111111111110101 K
b1111111111110101 m
b1111111111110101 w
b1111111111110101 |
b1101 A
b1101 E
b1101 b
0o
0>
#80
1o
1>
b1000 p
#85
b1111111111111101 ~
b1111111111111101 ?
b1111111111111101 _
b1111111111111101 K
b1111111111111101 m
b1111111111111101 w
b1111111111111101 |
b10101 A
b10101 E
b10101 b
0o
0>
#90
1o
1>
b1001 p
#95
b10000000000000101 ~
b10000000000000101 ?
b10000000000000101 _
b10000000000000101 K
b10000000000000101 m
b10000000000000101 w
b10000000000000101 |
b11101 A
b11101 E
b11101 b
0o
0>
#100
1o
1>
b1010 p
#105
b1111111111101101 ~
b1111111111101101 ?
b1111111111101101 _
b1111111111101101 K
b1111111111101101 m
b1111111111101101 w
b1111111111101101 |
b101 A
b101 E
b101 b
0o
0>
#110
1o
1>
b1011 p
#115
b1111111111110101 ~
b1111111111110101 ?
b1111111111110101 _
b1111111111110101 K
b1111111111110101 m
b1111111111110101 w
b1111111111110101 |
b1101 A
b1101 E
b1101 b
0o
0>
#120
1o
1>
b1100 p
#125
b1111111111111101 ~
b1111111111111101 ?
b1111111111111101 _
b1111111111111101 K
b1111111111111101 m
b1111111111111101 w
b1111111111111101 |
b10101 A
b10101 E
b10101 b
0o
0>
#130
1o
1>
b1101 p
#135
b10000000000000101 ~
b10000000000000101 ?
b10000000000000101 _
b10000000000000101 K
b10000000000000101 m
b10000000000000101 w
b10000000000000101 |
b11101 A
b11101 E
b11101 b
0o
0>
#140
1o
1>
b1110 p
#145
b1111111111101101 ~
b1111111111101101 ?
b1111111111101101 _
b1111111111101101 K
b1111111111101101 m
b1111111111101101 w
b1111111111101101 |
b101 A
b101 E
b101 b
0o
0>
#150
1o
1>
b1111 p
#155
b1111111111110101 ~
b1111111111110101 ?
b1111111111110101 _
b1111111111110101 K
b1111111111110101 m
b1111111111110101 w
b1111111111110101 |
b1101 A
b1101 E
b1101 b
0o
0>
#160
1o
1>
b10000 p
#165
b1111111111111101 ~
b1111111111111101 ?
b1111111111111101 _
b1111111111111101 K
b1111111111111101 m
b1111111111111101 w
b1111111111111101 |
b10101 A
b10101 E
b10101 b
0o
0>
#170
1o
1>
b10001 p
#175
b10000000000000101 ~
b10000000000000101 ?
b10000000000000101 _
b10000000000000101 K
b10000000000000101 m
b10000000000000101 w
b10000000000000101 |
b11101 A
b11101 E
b11101 b
0o
0>
#180
1o
1>
b10010 p
#185
b1111111111101101 ~
b1111111111101101 ?
b1111111111101101 _
b1111111111101101 K
b1111111111101101 m
b1111111111101101 w
b1111111111101101 |
b101 A
b101 E
b101 b
0o
0>
#190
1o
1>
b10011 p
#195
b1111111111110101 ~
b1111111111110101 ?
b1111111111110101 _
b1111111111110101 K
b1111111111110101 m
b1111111111110101 w
b1111111111110101 |
b1101 A
b1101 E
b1101 b
0o
0>
#200
1o
1>
b10100 p
